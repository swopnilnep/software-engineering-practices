<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Software Engineering Practices</title>
    <link>https://swopnilnep.github.io/software-engineering-practices/docs/</link>
    <description>Recent content in Docs on Software Engineering Practices</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://swopnilnep.github.io/software-engineering-practices/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter1/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter1/1/</guid>
      <description>Object Oriented Programming Object Oriented Programming is a programming paragdigm based on the concept of real world objects which contains functions (real world procedures, also known as methods) and attributes (data containing characteristics about the object).
The philosphical approach of Object Oriented programming is to use the divide and conquer method towards software problems.
Described in Sun Tzu&amp;rsquo;s &amp;ldquo;The Art of War&amp;rdquo;
 It is the rule in war, if ten times the enemy&amp;rsquo;s strength, surround them; if five times, attack them; if double be able to divide them; if equal,engage them; if fewer, defend against them; if weaker, be able to avoid them.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter1/2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter1/2/</guid>
      <description>Debugging Debugging is a technique of finding and resolving of defects that prevent correct operations of software systems
In the early days of computing, debugging was cumbersome but now debugging is more seamless because of various tools called debuggers.
We can use debuggers in various languages and various IDEs.
Here are some of the debugging techniques for the most common IDEs in some common OOP languages.
Debugging Process: Steps involved in debugging are:  Identifying the problem Assigning the report to software engineer to the defect to verify that it is genuine.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter1/3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter1/3/</guid>
      <description>User Interface Design The philosophy of good user interface design is to make simple designs that promote self exploration. While the interface should be clean, the main functions should be easily visible and runnable within less interactions.
One of the approach to designs from Henry Pertovski is that faliure in design is imperative as design is an iterative process so more valuable feedback comes from faliures rather than successes.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/1/</guid>
      <description>Project Organization and Management With companies facing increasing companies and change in technology, managing projects that last from a few weeks to several years can be a challenging task. Thankfully project organization allows this effort to be focused and efficiently targeted.
A project is defined as an undertaking that is:
 limited in time has a clear goal and a specific budget requiring a concerted effort  Hence tere are many facets of a project that must be managed by a project manager and the members of the teams undertaking that project.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/2/</guid>
      <description>Communication Communication is very important in software engineering and various guidelines need to be followed to maintain effective communication within internal and external stakeholders.
Communication Skills in SE  Collaboration: Negotiating requirements Presentation: Presenting the system during a review Technical Writing: Writing proposals and project documentation Maanagement: Facilitate team meetings, find compromises, negotiate conflicts etc.  People need to communicate more in larger companies as there are more stakeholders and more project working on the same project</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/3/</guid>
      <description>Software Lifecycle Models There are different questions in sofware development that lead to good software solutions. These questions are addressed by software development activites:
There are different questions in software development * Requirements Elicitation: What is the problem? * Requirements Analysis: Partition the problem into smaller pieces * System Design: Design solutions for * Object Design: What are the best mechanisms to implement the solution? * Implementation: How is the solution constructed?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/4/</guid>
      <description>Scrum There are two types of process controls in software engineering. These are defined process controls and empirical process control.
Defined process control are models loke waterfall or the v-model where processes are planned, follow strict rules and avoid deviations. They do not deal with change very well.
Empirical process controls are not entirely planned and allow the teams to inspect and adapt. The spiral model is an example of this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/5/</guid>
      <description>Prototyping Software development deals with complex system. Since the developer is not the same person as the user, the design of the software system is complicated and thus they must communicate with the user.
The user is always right becuase after all the user is the one using the software. This is why prototpying is required to enable software engineers and developers to communicate with users or customers.
Types of Prototyping Prototyping generally focus on three main characteristics that are longetivity, fidelity and stage of a software system.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter2/6/</guid>
      <description>UML Activity Diagram UML or Unified Modified Language is a visual language to visualize activites in software processes.
UML diagrams are of type softwarestructure diagrams or behaviour diagrams.
An activity diagram displays a sequence of actions, shows the behaviour of a system during analysis and models business processes.
These diagrams can model scrum or other software lifecycle models.
Here are some resources on exploring different types of diagrams and some more of UML activity diagrams.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter3/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter3/1/</guid>
      <description>Software Configuration Management Why Software Configuration Management is required * Promotion, Release, Revision Software Configuration Management allows you to * Track versions &amp;amp; collaborate * Change Management * Build and Release Management Multiple people work on artifacts that are changing: * More than one version of the artifact supported * Source Code * Documents * Released software system * Software is running on different machines, operating systems in the target environment * Need for coordination (software configuration management)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter3/2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter3/2/</guid>
      <description>Version Control Systems In the history of version control different approaches existed. Starting with local version control systems such as RCS of CVS that only stored versions on a local computer without any connection to other computers. Later centralized version control tools allowed collaboration between developers, for example subversion.
Nowadays distributed version control tools such as GIT are mostly used where developers can also send changes to each other without a remote repository.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter3/3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter3/3/</guid>
      <description>Distributed Version Control In a distributed version control system, there is a remote repository. While there can be multiple remote repositories, in most cases there&amp;rsquo;s only one. Developers have a local repository on the computer and interact with this local repository in order to obtain changes from the remote repository and in order to upload their changes to the remote repository. Other developers connect also over their local repository to the remote repository, so that they can exchange files and changes on these files.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter4/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter4/1/</guid>
      <description>Requirements Elicitation Requirement elicitation focus on the description and the purpose of a systems to be developed. The client developers and potential users identify a problem or even a problem area and therefore define the system to address the identified problem. Such a definition is called a requirement specification and it serves as an agreement or contract between the clients and the developers. The requirement specification is structured and formalized during the analysis phase and it&amp;rsquo;s based on a so called problem statement, which is described during requirement elicitation.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter4/2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter4/2/</guid>
      <description>Usability Usabilty is a multidimensional nonfunctional requirement in software engineering and UI design. Some systems are hard to understand and therefore also hard to use. This gets even worse when usability is not considered carefully enough.
Usability usually asks the following similar questions before adapting a particular feature into the UI:
 What is the level of expertise for the user or did your user use the computer before? What user interface standards are familiar to the user?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter4/3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter4/3/</guid>
      <description>Analysis The purpose of analysis is to create a model of the system which is correct, complete, consistent and also verifiable. This model is called the analysis model.
So we start from the requirements elicitation, go over to the requirements specification and describe the non-functional requirements and the functional model and then start with analysis.
Formalization During analysis we create a dynamic model and an analysis object model. These models can be used as a base for discussion going back towards requirements elicitation and refining existing models.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter4/4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter4/4/</guid>
      <description>UML Use Case Diagram The purpose of use case diagram is to capture the dynamic aspect of a system. However, this definition is too generic to describe the purpose, as other four diagrams (activity, sequence, collaboration, and Statechart) also have the same purpose. We will look into some specific purpose, which will distinguish it from other four diagrams.
 Use case diagrams are used to gather the requirements of a system including internal and external influences.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter5/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter5/1/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter5/2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter5/2/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter5/3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter5/3/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter5/4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter5/4/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter6/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter6/1/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter6/2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter6/2/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://swopnilnep.github.io/software-engineering-practices/docs/chapter6/3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swopnilnep.github.io/software-engineering-practices/docs/chapter6/3/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>